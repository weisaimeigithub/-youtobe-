# 课程收获
  面向对象思想，UML类图
  5大类设计原则，23种设计模式
  能应对前端面试中相关的面试题
  提升个人能力
  
# solid 五大设计原则
  s- 单一职责原则
     一个程序只做好一件事
     如果功能过于复杂就拆分开，每个部分保持独立
  o-开放封闭原则
     对扩展开发，对修改封闭
     增加需求时，扩展新代码，而非修改已有代码
     这是软件设计的终极目标
  l-李氏置换原则
     子类能覆盖父类
     父类能出现的地方子类就能出现
     js中使用较少（弱类型 & 继承使用较少）
  i-接口独立原则
     保持接口的单一独立，避免出现‘胖接口’
     js中没有接口（typescript除外），使用较少
     类似于单一职责原则，这里更关注接口
  d- 依赖导致原则
     面向接口编程，依赖于抽象而不依赖于具体
     使用方只关注接口而不关注具体类的实现
     js中使用较少（没有接口 & 弱类型）
# 从设计到模式
   设计
   模式
   分开
   从设计到模式
# 介绍23种设计模式
  创建型
      工厂模式（工厂方法模式，抽象工厂模式，建造者模式）
      单例模式
      原型模式
  结构型
      适配器模式
      装饰器模式
      代理模式
      外观模式
  行为型 -1
      策略模式
      迭代器模式
      模板方法模式
      职责连模式
      观察者模式
      命令模式
   行为模式 -2
      备忘录模式
      中介者模式
      状态模式
      解释器模式
      访问者模式
   （分优先级   前端常用设计模式，详讲  前端非常用设计模式，略讲  前端少用设计模式，介绍）

# 如何讲解设计模式？
  介绍和举例（生活中易理解的示例）
  画UML类图写demo代码
  结合经典应用场景，讲解该设计模式如何被使用
# 该如何学习设计模式
  明白每个设计的道理和用意
  通过经典应用体会它的真正使用场景
  自己编码时多思考，尽量模仿

# 面试题示例
  第一题：打车公司一面 第二题：短视频公司三面
  考察面向对象和设计能力
  面试有可能遇到，也有可能遇不到


# 4 工厂模式
  将new操作单独封装
  遇到new时，就要考虑是否该使用工厂模式
  
  示例：
     你去购买汉堡，直接点餐、取餐、不会自己亲手做
     商店要‘封装’做汉堡的工作，做好直接给买者

  见图： src/assets/img/传统UML类图.png    src/assets/img/简化后的UML类图.png  

  场景：jQuery-$('div')    React.createElement  vue异步组件
 

  # 设计原则验证
    构造函数和创建者分离
    符合开放封闭原则

 # 单例模式
    系统中被唯一使用
    一个类只有一个实例

    登录框 购物车  vuex和redux中的store


    说明：
    单例模式需要用到java的特性（private）
    es6中没有（typescript除外）
    只能用java代码来演示UML图的内容

    设计原则验证


    符合单一职责原则，只实例化唯一的对象
    没法具体开放封闭原则，但是绝对不违反开放封闭原则

# 适配器模式
    设计原则验证：将旧接口和使用者进行分离
    符合开放封闭原则

# 装饰器模式
   介绍
       为对象添加新功能
       不改变其原有的结构和功能
   场景
      ES7装饰器
         配置环境
         装饰类
         装饰方法
      core-decorators
         第三方开源lib
         提供常用的装饰器
         查阅文档：github.com/jayphelps/core-decorators

   设计原则验证
      将现有的对象和装饰器进行分离，两者独立存在
      符合开放封闭原则

   # 介绍
      使用者无权访问目标对象
      中间加代理，通过代理做授权和控制

   设计原则验证
     代理类和目标类分离，隔离开目标类和使用者
     符合开放封闭原则


## 代理模式 vs 适配器模式
   适配器模式：提供一个不同的接口（如不同版本的插头）
   代理模式：提供一模一样的接口
## 代理模式 vs 装饰器模式
   装饰器模式：扩展功能，原有功能不变且可直接使用
   代理模式：显示原有功能，但是经过限制或者阉割之后的


## 外观者模式
   为子系统中的一组接口提供了一个高层接口
   使用者使用这个高层接口


## 观察者模式
   发布 & 订阅
   一对多

   示例：点咖啡，点好之后做好等待被叫

   应用场景 nodejs  emit  处理http请求；多进程通讯
           vue 和 react 组件生命周期触发
            vue watch
         
   设计原则验证
    主题和观察者分离，不是主动触发而是被动监听，两者解耦
    符合开放封闭原则
   
## 迭代器模式
   顺序访问一个集合
   使用者无需知道集合的内部结构（封装）
   
ES6 Iterator为何存在
es6语法中，有序集合的数据类型已经有很多
Array Map Set String TypedArray arguments NodeList
需要有一个统一的遍历接口来遍历所有的数据类型
（注意，object不是有序集合，可以用Map代替）

Es6 iterator 是什么
以上数据类型，都有[Symbol.iterator]属性
属性值是函数，执行函数返回一个迭代器
这个迭代器就有next方法可顺序迭代子元素
可运行Array.prototype[Symbol.iterator]来测试
[
   Array.prototype[Symbol.iterator]
   Array.prototype[Symbol.iterator]()
   Array.prototype[Symbol.iterator]().next()
]

`Symbol.iterator`并不是人人都知道 也不是每个人都需要封装一个each方法  因此有了 `for ... of`语法


ES6 Iterator与 Generator
iterator的价值不限于上述类型的遍历
还有generator函数使用
即只要返回的数据符合Iterator接口的要求
即可使用Iterator语法，这就是迭代器模式

设计原则验证
迭代器对象和目标对象分离
迭代器将使用者与目标对象隔离开
符合开放封闭原则

## 介绍
 一个对象有状态变化
 每次状态变化都会触发一个逻辑
 不能总是用if...else来控制

 示例： 交通信号灯不同颜色变化

 # 场景
 有限状态机
    有限个状态，以及在这些状态之间变化
    如交通信号灯
    使用开源lib:javascript-state-machine
    开源地址库：https://github.com/jakesgordon/javascript-state-machine
 写一个简单的Promise
    回顾Promise的语法
    分析：Promise就是一个有限状态机

    Promise 三种状态：pending/fullfilled rejected
    pendding -> fullfilled 或者pending -> rejected

 ## 设计原则验证
    将状态对象和主体对象分离，状态的变化逻辑单独处理
    符合开放封闭原则

 
 ## 13 其他模式
    
    原型模式

    桥接模式

    组合模式
     整体和单个节点的操作是一致的
     整体和单个节点的数据结构也保持一致
        设计原则验证
        将整体和单个节点的操作抽象出来
        符合开放封闭原则

   享元模式

   策略模式
   
   模版方法模式
   
   职责连模式
      1 一步操作可能分为多个职责角色来完成
      2 把这些角色都分开，然后用一个链串起来
      3 将发起者和各个处理者进行隔离
   
      js中的链式操作
        职责链模式和业务结合较多，js中能联想到链式操作
        jQuery的链式操作 Promise.then的链式操作

   命令模式
      概念： 
          执行命令时，发布者和执行者分开
          中间加入命令对象，作为中转站

      发送者 ———（发出命令，调用命令对象）———> 命令对象 ——（接收命令、调用接受者对应接口）-——> 接受者
       
      js中的应用
         网页富文本编辑器操作，浏览器封装了一个命令 对象
         document.execCommand('bold')
         document.execCommand('undo')


      备忘录模式
         概念：
            随时记录一个对象的状态变化
            随时可以恢复之前的某个状态（如撤销功能）
            未找到js中经典应用，除了一些工具（如编辑器）
  

  ## 关于面试
     能说出课程重点讲解的设计模式即可【单例模式 工厂模式 观察者模式 代理模式 装饰器  适配器  迭代器  状态模式等掌握就行---基本的使用都得掌握】

 ## 日常使用
     重点讲解的设计模式，要强制自己模仿、掌握
     非常用的设计模式，视业务场景选择性使用

## 14 综合应用
   介绍： 使用jquery 做一个模拟购物车的示例
         显示购物车列表、加入购物车、从购物车删除

   用到的设计模式
      工厂模式 单例模式
      装饰器模式 观察者模式
      状态模式 模版方法模式 代理模式

## 以前想怎么梳理一段代码 自己想要梳理 没有发明不出来合适的方法，其实早就有了UML类图
   自己并不清楚，你想要做的很多都有了工具，百分之99 都有，只不过你找不到而已。